<?xml version="1.0" encoding="UTF-8" standalone="no"?><umlet_diagram><help_text>// Uncomment the following line to change the fontsize:
// fontsize=14


//////////////////////////////////////////////////////////////////////////////////////////////
// Welcome to UMLet!
//
// Double-click on UML elements to add them to the diagram, or to copy them
// Edit elements by modifying the text in this panel
// Hold Ctrl to select multiple elements
// Use Ctrl+mouse to select via lasso
//
// Use Â± or Ctrl+mouse wheel to zoom
// Drag a whole relation at its central square icon
//
// Press Ctrl+C to copy the whole diagram to the system clipboard (then just paste it to, eg, Word)
// Edit the files in the "palettes" directory to create your own element palettes
//
// Select "Custom Elements &gt; New..." to create new element types
//////////////////////////////////////////////////////////////////////////////////////////////


// This text will be stored with each diagram;  use it for notes.</help_text><zoom_level>7</zoom_level><element><type>com.umlet.element.base.Class</type><coordinates><x>1477</x><y>259</y><w>210</w><h>497</h></coordinates><panel_attributes>Actors::Actor
--
String: name
Sprite: sprite
int: level
int: exp
int: hp
int[]: mp
int: strength
int: defense
int: speed
int: evasion
int: magic
int: resistance
boolean: alive
Command: action
Skill[]: abilities
--
void setCommand(Command a)
int execute()
 
void setName(String n)
void setHP(int i)
void setMP(int[] i)
void setStr(int i)
void setDef(int i)
void setSpd(int i)
void setEva(int i)
void setMag(int i)
void setRes(int i)
void setExp(int i)

String getName()
int getHP()
int[] getMP()
int getStr()
int getDef()
int getSpd()
int getEva()
int getMag()
int getRes()
int getExp()
 
boolean getAlive()
void paint(Graphics g)
Sprite getSprite()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1281</x><y>315</y><w>147</w><h>84</h></coordinates><panel_attributes>Actors::Enemy
--
Item: itemDrop
--
void setDrop(Item i)
Item getDrop()
 
void draw()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1764</x><y>182</y><w>147</w><h>245</h></coordinates><panel_attributes>Actors:Player
--
Job: job
Items[]: equipment
--
void setJob(Job j)
 
void setWeaponL(Item i)
void setWeaponR(Item i)
void setHelm(Item i)
void setArmor(Item i)
void setAccessory(Item i)
void setEquipment(Item[] i)
void setJob(Job j)
 
void getWeaponL(Item i)
void getWeaponR(Item i)
void getHelm(Item i)
void getArmor(Item i)
void getAccessory(Item i)
void getEquipment(Item[] i)
 
final int getExpCurve(int l)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2114</x><y>147</y><w>147</w><h>210</h></coordinates><panel_attributes>&lt;&lt;Abstract&gt;&gt;
Jobs::Job
--
protected String: name
protected String[]: equippableTypes
protected Skills[]: skillList
--
abstract int getHP(int lvl)
abstract int[] getMP(int lvl)
abstract int getStr(int lvl)
abstract int getDef(int lvl)
abstract int getSpd(int lvl)
abstract int getEvd(int lvl)
abstract int getMag(int lvl)
abstract int getRes(int lvl)
 
String getName()
  
String[] getEquippable()
String[] getSkills(int lvl)



</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2303</x><y>77</y><w>147</w><h>140</h></coordinates><panel_attributes>Jobs::Fighter
--
String: name
String[]: equippableTypes
Skills[]: skillList

--
int getHP(int lvl)
int[] getMP(int lvl)
int getStr(int lvl)
int getDef(int lvl)
int getSpd(int lvl)
int getEvd(int lvl)
int getMag(int lvl)
int getRes(int lvl)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2303</x><y>238</y><w>147</w><h>140</h></coordinates><panel_attributes>Jobs::Monk
--
String: name
String[]: equippableTypes
Skills[]: skillList
--
int getHP(int lvl)
int[] getMP(int lvl)
int getStr(int lvl)
int getDef(int lvl)
int getSpd(int lvl)
int getEvd(int lvl)
int getMag(int lvl)
int getRes(int lvl)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2303</x><y>399</y><w>147</w><h>140</h></coordinates><panel_attributes>Jobs::Thief
--
String: name
String[]: equippableTypes
Skills[]: skillList
--
int getHP(int lvl)
int[] getMP(int lvl)
int getStr(int lvl)
int getDef(int lvl)
int getSpd(int lvl)
int getEvd(int lvl)
int getMag(int lvl)
int getRes(int lvl)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2114</x><y>399</y><w>147</w><h>140</h></coordinates><panel_attributes>Jobs::Red Mage
--
String: name
String[]: equippableTypes
Skills[]: skillList
--
int getHP(int lvl)
int[] getMP(int lvl)
int getStr(int lvl)
int getDef(int lvl)
int getSpd(int lvl)
int getEvd(int lvl)
int getMag(int lvl)
int getRes(int lvl)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1925</x><y>399</y><w>147</w><h>140</h></coordinates><panel_attributes>Jobs::White Mage
--
String: name
String[]: equippableTypes
Skills[]: skillList

--
int getHP(int lvl)
int[] getMP(int lvl)
int getStr(int lvl)
int getDef(int lvl)
int getSpd(int lvl)
int getEvd(int lvl)
int getMag(int lvl)
int getRes(int lvl)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1925</x><y>238</y><w>147</w><h>140</h></coordinates><panel_attributes>Jobs::Black Mage
--
String: name
String[]: equippableTypes
Skills[]: skillList

--
int getHP(int lvl)
int[] getMP(int lvl)
int getStr(int lvl)
int getDef(int lvl)
int getSpd(int lvl)
int getEvd(int lvl)
int getMag(int lvl)
int getRes(int lvl)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2240</x><y>133</y><w>76</w><h>34</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>21;21;63;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2240</x><y>273</y><w>76</w><h>34</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>21;21;63;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2240</x><y>336</y><w>76</w><h>76</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>21;21;63;63</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2163</x><y>336</y><w>34</w><h>76</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>21;21;21;63</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2051</x><y>336</y><w>76</w><h>76</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>63;21;21;63</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2051</x><y>266</y><w>76</w><h>34</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>63;21;21;21</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1190</x><y>686</y><w>203</w><h>175</h></coordinates><panel_attributes>engine::Engine
&lt;&lt;KeyListener, Runnable&gt;&gt;
--
ActorGroup&lt;Player&gt;: party
 
GameScreen: screen
 
static Engine: _instance
 
Scene: currentScene
 
static void main(String[] args)
--
static Engine getInstance()

</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1218</x><y>539</y><w>147</w><h>77</h></coordinates><panel_attributes>Grouping::Party
extends ArrayList&lt;Player&gt;
--
void add(String n, String job)
Actor[] getAliveMembers()
int getAlive()

</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1407</x><y>308</y><w>83</w><h>34</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>70;21;21;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1666</x><y>287</y><w>111</w><h>34</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>21;21;98;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1890</x><y>196</y><w>237</w><h>34</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>224;21;21;21</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>2016</x><y>658</y><w>371</w><h>84</h></coordinates><panel_attributes>Note..
bg=red
Command Pattern
 
Actors execute their actions using "commands".  These commands
range from attacking with weapons, to using magic spells, as well as
protecting oneself.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>1036</x><y>511</y><w>168</w><h>91</h></coordinates><panel_attributes>Note..
bg=blue
The grouping system helps
organize Actors into groups
for battle.  They also keep track
of helpful numbers such as how
many of that actor type is alive
in the battle.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1281</x><y>595</y><w>34</w><h>104</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>21;21;21;91</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>763</x><y>1078</y><w>182</w><h>119</h></coordinates><panel_attributes>GUI::HUD
&lt;&lt;Component&gt;&gt;
--
PartyStatusDisplay: pStatDisplay
CommandDisplay: cDisplay
EnemySpriteDisplay: eSpriteDisplay
PartySpriteDisplay: pSpriteDisplay
TurnDialog: turnDisplay
Font: font
--
void paintComponent(Graphics g)
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>763</x><y>1239</y><w>147</w><h>77</h></coordinates><panel_attributes>&lt;&lt;Component&gt;&gt;
GUI::PartyStatusDisplay
--
StatusWindow[]: windows
--
void paintComponent(Graphics g)

</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>763</x><y>1365</y><w>147</w><h>63</h></coordinates><panel_attributes>&lt;&lt;Component&gt;&gt;
GUI::StatusWindow
--
Actor actor;
--
void paintComponent(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>791</x><y>1295</y><w>28</w><h>77</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>21;70;21;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>791</x><y>1176</y><w>28</w><h>70</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>21;63;21;21</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>980</x><y>1078</y><w>147</w><h>49</h></coordinates><panel_attributes>GUI::CommandDisplay
&lt;&lt;Component&gt;&gt;
--
void paintComponent(Graphics g)
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>924</x><y>1085</y><w>63</w><h>28</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>56;21;21;21</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1211</x><y>1078</y><w>147</w><h>49</h></coordinates><panel_attributes>GUI::SkillDisplay
&lt;&lt;Component&gt;&gt;
--
void paintComponent(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1106</x><y>1085</y><w>112</w><h>28</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>21;21;105;21</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>980</x><y>1162</y><w>147</w><h>42</h></coordinates><panel_attributes>&lt;&lt;Component&gt;&gt;
GUI::PartySpriteDisplay
--
void paintComponent(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>980</x><y>1253</y><w>147</w><h>42</h></coordinates><panel_attributes>&lt;&lt;Component&gt;&gt;
GUI::EnemySpriteDisplay
--
void paintComponent(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1169</x><y>1204</y><w>147</w><h>42</h></coordinates><panel_attributes>&lt;&lt;Component&gt;&gt;
GUI::SpriteDisplay
--
void paintComponent(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>924</x><y>1141</y><w>63</w><h>28</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>56;21;21;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>896</x><y>1176</y><w>91</w><h>84</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>84;77;21;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>833</x><y>1001</y><w>28</w><h>84</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>21;21;21;77</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>777</x><y>987</y><w>175</w><h>35</h></coordinates><panel_attributes>GUI::TurnDisplay
--
void paintComponent(Graphics g)
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1106</x><y>1155</y><w>70</w><h>70</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>63;63;21;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1106</x><y>1211</y><w>70</w><h>63</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>63;21;21;56</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>714</x><y>525</y><w>91</w><h>630</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>49;623;21;623;21;21;84;21</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>980</x><y>1330</y><w>364</w><h>42</h></coordinates><panel_attributes>Note..
bg=blue
The gui follows no real pattern.  Things drawn to screen are determined
by the engine's state.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1547</x><y>840</y><w>154</w><h>259</h></coordinates><panel_attributes>GUI::Sprite
&lt;&lt;Component&gt;&gt;
--
int width
int height
int x
int y
 
BufferedImage image
--
loadImage(String s)
 
getWidth()
getHeight()
setWidth()
setHeight()
 
getX()
getY()
setX()
setY()
 
paintComponent(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1589</x><y>735</y><w>34</w><h>118</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>21;105;21;21</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>350</x><y>399</y><w>154</w><h>63</h></coordinates><panel_attributes>battleSystem::EngageState
Execute commands
--
void start()
void handle()
void finish()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>560</x><y>455</y><w>147</w><h>70</h></coordinates><panel_attributes>&lt;&lt;Interface&gt;&gt;
battleSystem::BattleState
--
void start()
void handle()
void finish()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>350</x><y>490</y><w>154</w><h>63</h></coordinates><panel_attributes>battleSystem::MessageState
Display turn results
--
void start()
void handle()
void finish()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>350</x><y>308</y><w>154</w><h>63</h></coordinates><panel_attributes>battleSystem::IssueState
Issuing Commands
--
void start()
void handle()
void finish()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>1022</x><y>868</y><w>329</w><h>133</h></coordinates><panel_attributes>Note..
bg=red
Singleton Pattern
 
The engine itself is a singleton pattern, allowing only one
instance of itself.  This is so things such as scenes and
the gui can reference the engine for the party and formation
it is storing for battle.  The engine also keeps track of the actor
turn order while they are engaged in battle.  Additionally, it
handles key input which is necessary for switching between
states and selecting commands to execute.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>350</x><y>581</y><w>154</w><h>63</h></coordinates><panel_attributes>battleSystem::ResultsState
Display Battle results
--
void start()
void handle()
void finish()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>0</x><y>308</y><w>329</w><h>287</h></coordinates><panel_attributes>Note..
bg=red
State Pattern
 
Battle is divided into 4 different states.
 
IssueState allows the user to select a command for the party 
member to execute.  Upon selecting a command the engine's 
commandIndex is incremented, and when that is larger than the
party's size, turn order is determined and EngageState starts
 
EngageState executes all the actor's commands and deals the
damage.  Upon executing and completing MessageState is active
 
MessageState shows the results of the turn just executed in
text format for the user to understand.  When this is done
showing, EngageState will start for the next actor.  If there are
no more actors with actions the game will go back to IssueState.
If there are no more actors alive in either group, the game will
enter into ResultsState
 
ResultsState displays the battle's results.  Upon death of the
whole party, Game Over is displayed in a message box and the
game will close.  Upon the formation dying, exp, gold, and items
will be rewarded to the party.  In this test the party will full heal
and another battle will commence.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>686</x><y>476</y><w>119</w><h>28</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>21;21;112;21</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>798</x><y>448</y><w>224</w><h>189</h></coordinates><panel_attributes>battleSystem::BattleSystem
&lt;&lt;Scene, Thread, Component&gt;&gt;
--
Engine: e
MP3: music
HUD: hud
HashMap&lt;Integer, Actor&gt;: allActors
Queue&lt;Actor&gt;: turnOrder
int: commandIndex
 
BattleState: state
 
ActorGroup&lt;Enemy&gt;: formation
--
void start()
void stop()
void next()
void render(Graphics2D g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1001</x><y>693</y><w>196</w><h>28</h></coordinates><panel_attributes>lt=&lt;&lt;-&gt;&gt;</panel_attributes><additional_attributes>21;21;189;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1001</x><y>469</y><w>287</w><h>28</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>280;21;21;21</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>749</x><y>301</y><w>329</w><h>126</h></coordinates><panel_attributes>Note..
bg=red
Strategy Pattern
 
Scenes also follow the Strategy pattern in that all scenes
follow the basic threaded structure of start() run() stop()
but do different but similar things in those general methods.
It simplifies the game structure to having one engine and
different scenes instead of different engines for battle, party
selection, and map wandering (which the threading capabilites
would become extremely handy for dealing with npc movement).</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>1029</x><y>623</y><w>224</w><h>49</h></coordinates><panel_attributes>Note..
bg=blue
scenes are threaded, though this
isn't exactly evident in a linear turn based
battle scene.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>1708</x><y>938</y><w>175</w><h>126</h></coordinates><panel_attributes>Note..
bg=blue
Sprites are used to easily manage
and draw images to the screen.
This includes HUD windows and 
player/enemy images.
 
loadImage will load the file and
turn it into a BufferedImage which
can then be drawn to screen.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1869</x><y>763</y><w>147</w><h>119</h></coordinates><panel_attributes>&lt;&lt;Abstract&gt;&gt;
Commands::Command
--
String: name
Actor: target
Actor: invoker
int damage
DamageBehavior: db
--
abstract void execute()
void setTarget()
int getDamage()
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2086</x><y>777</y><w>182</w><h>70</h></coordinates><panel_attributes>&lt;&lt;Interface&gt;&gt;
Commands::DamageBehavior
--
boolean didHit(int bonus)
int calcDamage(Actor attacker, 
                               Actor target);
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2310</x><y>770</y><w>196</w><h>42</h></coordinates><panel_attributes>Commands::PhysicalDamageBehavior
--
boolean didHit(int bonus)
boolean critical()
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2016</x><y>917</y><w>147</w><h>35</h></coordinates><panel_attributes>Commands::Attack
--
void execute()
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2247</x><y>770</y><w>70</w><h>28</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>21;21;63;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2247</x><y>812</y><w>70</w><h>28</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>21;21;63;21</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2310</x><y>819</y><w>196</w><h>35</h></coordinates><panel_attributes>Commands::MagicDamageBehavior
--
boolean didHit(int bonus)
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1995</x><y>861</y><w>28</w><h>56</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>21;21;21;49</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1995</x><y>959</y><w>147</w><h>28</h></coordinates><panel_attributes>Commands::Defend
--
void execute()
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1974</x><y>861</y><w>28</w><h>105</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>21;21;21;98</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1666</x><y>672</y><w>216</w><h>104</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>203;91;21;21</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>2016</x><y>560</y><w>371</w><h>84</h></coordinates><panel_attributes>Note..
bg=red
Strategy Pattern
 
Jobs that players possess determine how much of each stat the Player
has.  Different jobs have different algorithms for determining each stat 
dependent on the player's level.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>2219</x><y>875</y><w>392</w><h>210</h></coordinates><panel_attributes>Note..
bg=red
Strategy Pattern
 
The way commands deal damage is divided up int different calculations
that are shared between many types of commands.  The different damage
behaviors are Physical and Magical.
 
With physical, damage is determined by the attacker's strength and the
target's defense, which if the target used the defend command, their defense
is 2x what it normally is.
 
With magical, damage is determined by the attacker's magic power and the
target's resistance.
 
didHit() is evoked during execute before damage is calculated to make sure
the attack even lands.  It is determined by the target's evade and the 
attacker's speed plus a bonus determined by the command itself.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1995</x><y>791</y><w>98</w><h>28</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>91;21;21;21</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>798</x><y>784</y><w>245</w><h>77</h></coordinates><panel_attributes>GUI::GameScreen
&lt;&lt;JPanel&gt;&gt;
--
static final int FRAME_WIDTH
static final int FRAME_HEIGHT
static final Color BACKGROUND;
--
void paintComponents(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1022</x><y>784</y><w>175</w><h>28</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>21;21;168;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>742</x><y>693</y><w>63</w><h>147</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>56;21;21;21;21;140;56;140</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1281</x><y>441</y><w>147</w><h>91</h></coordinates><panel_attributes>Grouping::Formation
extends ArrayList&lt;Enemy&gt;
--
void add(String n)
void add(String[] n)
 
Enemy[] getAliveMembers()
int getAlive()



</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1330</x><y>378</y><w>34</w><h>76</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>21;21;21;63</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1218</x><y>175</y><w>559</w><h>377</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>546;21;21;21;21;364</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1365</x><y>882</y><w>147</w><h>91</h></coordinates><panel_attributes>engine::Input
--
final static int KEY_A
final static int KEY_B
final static int KEY_UP
final static int KEY_DN
final static int KEY_LT
final static int KEY_RT</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1372</x><y>812</y><w>63</w><h>77</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>56;70;21;21</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>798</x><y>665</y><w>224</w><h>112</h></coordinates><panel_attributes>engine::Scene
extends JComponent implements Runnable
--
Engine: e
--
void start()
void stop()
void next()
void render(Graphics2D g)
 
final void paintComponent(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>875</x><y>616</y><w>28</w><h>56</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>21;49;21;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>483</x><y>329</y><w>84</w><h>133</h></coordinates><panel_attributes>lt=&lt;&lt;&lt;-</panel_attributes><additional_attributes>77;126;21;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>483</x><y>420</y><w>84</w><h>70</h></coordinates><panel_attributes>lt=&lt;&lt;&lt;-</panel_attributes><additional_attributes>77;63;21;21</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>483</x><y>476</y><w>84</w><h>63</h></coordinates><panel_attributes>lt=&lt;&lt;&lt;-</panel_attributes><additional_attributes>77;21;21;56</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>483</x><y>504</y><w>84</w><h>112</h></coordinates><panel_attributes>lt=&lt;&lt;&lt;-</panel_attributes><additional_attributes>77;21;21;105</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>1365</x><y>980</y><w>154</w><h>70</h></coordinates><panel_attributes>Note..
bg=blue
Input class offers a simple
wrapper for input variables
to match the naming scheme
that is common to gamepads</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>2513</x><y>763</y><w>210</w><h>63</h></coordinates><panel_attributes>Note..
bg=blue
Physical attacks also have a chance to 
deal critical damage, which is double the
amount of the normal amount of damage
dealt.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>1694</x><y>434</y><w>224</w><h>259</h></coordinates><panel_attributes>Note..
bg=blue
Level - the actor's level
exp - exp to next level
      (enemy = exp reward upon killing)
getExpCurve (player only) will return the 
       amount of exp necessary to level up
 
HP - hit points, when 0 the actor is dead
                     (can be retrieved using getAlive())
MP - is an array due to being styled after
          D&amp;D magic casting rules
Strength - Physical Attack power
Defense - Resistance against physical 
          attacks
Speed - Determines turn order and chance
          of landing an attack
Evasion - Chance of dodging and attack
Magic - Magical Attack power
Resistance - Magical defense power
Alive - is the actor capable of acting
Action - command to be executed on the
          actor's turn
Abilities - special commands the actor is
          capable of executing

paint(Graphics g) will draw the actor's sprite</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>763</x><y>1435</y><w>147</w><h>49</h></coordinates><panel_attributes>Note..
bg=blue
Status windows display the
name and HP of the player</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>574</x><y>1253</y><w>168</w><h>56</h></coordinates><panel_attributes>Note..
bg=blue
Group of status windows to
display all of the party member's
stats in battle</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>1323</x><y>1197</y><w>175</w><h>63</h></coordinates><panel_attributes>Note..
bg=blue
Sprite displays display a window
with a background strip across the
top and all the sprites of the party
or formation arranged within it</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>980</x><y>1015</y><w>252</w><h>56</h></coordinates><panel_attributes>Note..
bg=blue
CommandDisplay displays a window with the name
of selectable commands for the party member to be
assigned to execute upon their turn</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>763</x><y>924</y><w>203</w><h>56</h></coordinates><panel_attributes>Note..
bg=blue
TurnDisplay displays the message
created during the messageState so the
user is notified of the turn's results</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>1288</x><y>252</y><w>133</w><h>56</h></coordinates><panel_attributes>Note..
bg=blue
Enemies also can hold an
item which it may drop
upon being defeated</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>1736</x><y>7</y><w>203</w><h>168</h></coordinates><panel_attributes>Note..
bg=blue
Players can have a set of items which get
equipped and grant the player bonuses
to his/her stats.
 
Equippable items fall under categories
WeaponL - Left hand weapon
WeaponR - Right hand weapon
Helm - Helmet
Armor - Chest armor
Accessory - additional accesory
 
They can be assigned in a group or all
at once as a set</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>56</x><y>819</y><w>385</w><h>119</h></coordinates><panel_attributes>Note..
bg=orange
FF1-Battle-System
 
This program is aimed to recreate (for now) the Battle System used in the original
Final Fantasy for the Nintendo Entertainment System.  This includes graphical style
as well, so it won't look like the remastered versions.
 
Players will be able to create a party of 4 ponies, 6 ponies/jobs to chose from for
each member.  The battle system is turn-based and dependent on the user
assigning commands to the party members so they may attack the enemies.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>525</x><y>777</y><w>203</w><h>77</h></coordinates><panel_attributes>Note..
bg=blue
FINAL_WIDTH determines the width of the 
           game window
FINAL_HEIGHT determines the height of the
           game window
BACKGROUND color for the window's back</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>560</x><y>532</y><w>168</w><h>189</h></coordinates><panel_attributes>Note..
bg=blue
music - The battlesystem is capable
    of playing invigorating music
    during the battle
 
allActors - a map of all the alive
   actors and their speed which
   which is used for figuring out
   turn order
 
commandIndex - only used during
the Issuing state, it's the current
index of the command that is
selected in the command choices</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>280</x><y>945</y><w>161</w><h>98</h></coordinates><panel_attributes>Legend</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>280</x><y>945</y><w>140</w><h>49</h></coordinates><panel_attributes>lt=&lt;&lt;-
Has A</panel_attributes><additional_attributes>21;35;133;35</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>280</x><y>987</y><w>140</w><h>49</h></coordinates><panel_attributes>lt=&lt;&lt;&lt;-
Implements</panel_attributes><additional_attributes>21;35;133;35</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>280</x><y>966</y><w>140</w><h>49</h></coordinates><panel_attributes>lt=&lt;.
Extends</panel_attributes><additional_attributes>21;35;133;35</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>1932</x><y>1120</y><w>196</w><h>119</h></coordinates><panel_attributes>Note..
bg=blue
Just for basic testing there will only be
the ability to choose command, defend,
and a few level 1 spells.
 
Because spells are actually learned
through using and item to teach the
character it, in the future command may
be split even further into battle command
and menu commands</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1974</x><y>994</y><w>147</w><h>35</h></coordinates><panel_attributes>Commands::Fire
--
void execute()
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1953</x><y>861</y><w>28</w><h>140</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>21;21;21;133</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1953</x><y>1036</y><w>147</w><h>35</h></coordinates><panel_attributes>Commands::Ice
--
void execute()
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1932</x><y>861</y><w>28</w><h>182</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>21;21;21;175</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1932</x><y>1078</y><w>147</w><h>35</h></coordinates><panel_attributes>Commands::Heal
--
void execute()
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1911</x><y>861</y><w>28</w><h>224</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>21;21;21;217</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>1106</x><y>385</y><w>126</w><h>98</h></coordinates><panel_attributes>Note..
bg=blue
Formations can not only
generate an enemy by
passing the class name,
but it can also generate
a group of enemies for
it to keep track of by
passing an array of names</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>2065</x><y>56</y><w>217</w><h>77</h></coordinates><panel_attributes>Note..
bg=blue
Equipment that can be equipped by the actor
is restricted to the job of the actor.

Skills that can be learned are also restricted
by job.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>2464</x><y>140</y><w>154</w><h>203</h></coordinates><panel_attributes>Note..
bg=blue

Jobs do not have setter methods
for retrieving stat values.  This
is because stat getters should
be equations dependent on
the actor's level.</panel_attributes><additional_attributes/></element></umlet_diagram>