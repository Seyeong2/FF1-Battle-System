<?xml version="1.0" encoding="UTF-8" standalone="no"?><umlet_diagram><help_text>// Uncomment the following line to change the fontsize:
// fontsize=14


//////////////////////////////////////////////////////////////////////////////////////////////
// Welcome to UMLet!
//
// Double-click on UML elements to add them to the diagram, or to copy them
// Edit elements by modifying the text in this panel
// Hold Ctrl to select multiple elements
// Use Ctrl+mouse to select via lasso
//
// Use Â± or Ctrl+mouse wheel to zoom
// Drag a whole relation at its central square icon
//
// Press Ctrl+C to copy the whole diagram to the system clipboard (then just paste it to, eg, Word)
// Edit the files in the "palettes" directory to create your own element palettes
//
// Select "Custom Elements &gt; New..." to create new element types
//////////////////////////////////////////////////////////////////////////////////////////////


// This text will be stored with each diagram;  use it for notes.</help_text><zoom_level>10</zoom_level><element><type>com.umlet.element.base.Class</type><coordinates><x>3340</x><y>520</y><w>300</w><h>770</h></coordinates><panel_attributes>Actors::Actor
--
String: name

Sprite[]: sprites

int: level
int: exp
int: hp
int[]: mp
int: str
int: def
int: spd
int: evd
int: itl
int: mdef
int: luk

Command: action
Command[]: commands
Skill[]: abilities
--
void setCommand(Command a)
int execute()
 
void setName(String n)
void setHP(int i)
void setMP(int[] i)
void setStr(int i)
void setDef(int i)
void setSpd(int i)
void setEvd(int i)
void setInt(int i)
void setMDef(int i)
void setLuck(int i)
void setExp(int i)

String getName()
int getHP()
int[] getMP()
int getStr()
int getDef()
int getSpd()
int getEvd()
int getInt()
int getMDef()
int getLuck()
int getExp()
 
boolean getAlive()
void paint(Graphics g)
Sprite getSprite()
void loadSprites()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>3060</x><y>600</y><w>210</w><h>120</h></coordinates><panel_attributes>Actors::Enemy
--
Item: itemDrop
--
void setDrop(Item i)
Item getDrop()
 
void draw()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>3750</x><y>410</y><w>210</w><h>320</h></coordinates><panel_attributes>Actors:Player
--
public static final int STAND
public static final int WALK
public static final int ACT
public static final int CAST
public static final int VICT
public static final int DEAD
public static final int WEAK
 
protected int state
protected int moving
 
protected Sprite drawSprite
protected double x
protected double y	
--
final int getExpCurve(int l)

void setState(int i)
void setMoving(int i)
void setPosition(int x, int y)
void setX(int i)
void setY(int i)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>4250</x><y>360</y><w>210</w><h>300</h></coordinates><panel_attributes>&lt;&lt;Abstract&gt;&gt;
Jobs::Job
--
protected String: name
protected String[]: equippableTypes
protected Skills[]: skillList
--
int getHP(int lvl)
int[] getMP(int lvl)
int getStr(int lvl)
int getDef(int lvl)
int getSpd(int lvl)
int getEvd(int lvl)
int getMag(int lvl)
int getRes(int lvl)
 
String getName()
  
String[] getEquippable()
String[] getSkills(int lvl)



</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2930</x><y>1130</y><w>290</w><h>250</h></coordinates><panel_attributes>engine::Engine
--
ActorGroup&lt;Player&gt;: party

static Engine: _instance
 
Scene: currentScene
--
static Engine getInstance()

</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2970</x><y>920</y><w>210</w><h>110</h></coordinates><panel_attributes>Grouping::Party
extends ArrayList&lt;Player&gt;
--
void add(String n, String job)
Actor[] getAliveMembers()
int getAlive()

</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3240</x><y>590</y><w>110</w><h>40</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>100;30;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3610</x><y>560</y><w>160</w><h>50</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>30;30;140;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3930</x><y>430</y><w>340</w><h>50</h></coordinates><panel_attributes>lt=-&gt;&gt;</panel_attributes><additional_attributes>320;30;30;30</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>4140</x><y>1230</y><w>530</w><h>120</h></coordinates><panel_attributes>Note..
bg=red
Command Pattern
 
Actors execute their actions using "commands".  These commands
range from attacking with weapons, to using magic spells, as well as
protecting oneself.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>2710</x><y>880</y><w>240</w><h>130</h></coordinates><panel_attributes>Note..
bg=blue
The grouping system helps
organize Actors into groups
for battle.  They also keep track
of helpful numbers such as how
many of that actor type is alive
in the battle.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3060</x><y>1000</y><w>50</w><h>150</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;30;130</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>1150</y><w>400</w><h>110</h></coordinates><panel_attributes>scenes.BattleScene.System::EngageState
Execute commands
--
Actor activeActor
--
void start()
void handle()
void finish()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>1280</y><w>400</w><h>140</h></coordinates><panel_attributes>scenes.BattleScene.System::MessageState
Display turn results
--
String message
Actor activeActor
--
String getMessage()
void start()
void handle()
void finish()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>830</y><w>400</w><h>290</h></coordinates><panel_attributes>scenes.BattleScene.System::IssueState
Issuing Commands
--
Player actor
Actor target
Actor[] targets
Command c
int index
boolean targetSelecting
boolean spellSelecting
boolean goBack
--
void start()
void handle()
void finish()
void next()
int getIndex()
void handleKeyInput(KeyEvent arg0)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>2880</x><y>1410</y><w>470</w><h>190</h></coordinates><panel_attributes>Note..
bg=red
Singleton Pattern
 
The engine itself is a singleton pattern, allowing only one
instance of itself.  This is so things such as scenes and
the gui can reference the engine for the party and formation
it is storing for battle.  The engine also keeps track of the actor
turn order while they are engaged in battle.  Additionally, it
handles key input which is necessary for switching between
states and selecting commands to execute.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>1440</y><w>400</w><h>90</h></coordinates><panel_attributes>scenes.BattleScene.System::VictoryState
Display Battle results when won
--
void start()
void handle()
void finish()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>230</x><y>590</y><w>500</w><h>410</h></coordinates><panel_attributes>Note..
bg=red
State Pattern
 
Battle is divided into 6 different states.
 
IssueState allows the user to select a command for the party 
member to execute.  Upon selecting a command the engine's 
commandIndex is incremented, and when that is larger than the
party's size, turn order is determined and EngageState starts
 
EngageState executes all the actor's commands and deals the
damage.  Upon executing and completing MessageState is active
 
MessageState shows the results of the turn just executed in
text format for the user to understand.  When this is done
showing, EngageState will start for the next actor.  If there are
no more actors with actions the game will go back to IssueState.
If there are no more actors alive in either group, the game will
enter into ResultsState
 
Victory/GameOverState displays the battle's results.  Upon death
of the whole party, Game Over is displayed in a message box and the
game will close.  Upon the formation dying, exp, gold, and items
will be rewarded to the party.  In this test the party will full heal
and another battle will commence.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1870</x><y>430</y><w>320</w><h>520</h></coordinates><panel_attributes>scenes.BattleScene.System::BattleSystem
--
Engine engine
	
Actor[] allActors
Queue&lt;Actor&gt; turnOrder

Party party
Formation formation

Actor activeActor

int playerIndex

IssueState is
EngageState es
MessageState ms
GameOverState gs
VictoryState vs
	
MP3 bgm
--
void genEnemyCommands()
Actor getActiveActor()
Formation getFormation()
Actor getRandomTarget(Actor)
Actor[] getTargets(Actor)
Queue&lt;Actor&gt; getTurnOrder()
void keyPressed(KeyEvent)
void next()
void populateActorList()
void previous()
void setFormation(Formation)
void setNextState()
void start()
void update()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2800</x><y>1170</y><w>150</w><h>50</h></coordinates><panel_attributes>lt=&lt;&lt;-&gt;&gt;</panel_attributes><additional_attributes>30;30;130;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2160</x><y>820</y><w>920</w><h>50</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>900;30;30;30</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>2170</x><y>1010</y><w>470</w><h>110</h></coordinates><panel_attributes>Note..
bg=red
State Pattern
 
Scenes follow the state pattern as well.  When the game changes
state/scene, the entire experience of the game changes to what
that scene does.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>3370</x><y>1930</y><w>260</w><h>250</h></coordinates><panel_attributes>Note..
bg=blue
Sprites are used to easily manage
and draw images to the screen.
This includes HUD windows and 
player/enemy images.
 
loadImage will load the file and
turn it into a BufferedImage which
can then be drawn to screen.
 
Windows are a complex system of
buffered images that will stretch
and be rendered as a single image
that looks as though it frames 
text of images.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>3900</x><y>1210</y><w>210</w><h>200</h></coordinates><panel_attributes>&lt;&lt;Abstract&gt;&gt;
Commands::Command
--
String: name
Actor: invoker
int: damage
int: hits
--
abstract void execute()
int getDamage()
int getHits()
void calculateDamage()
String toString()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>4080</x><y>1500</y><w>210</w><h>50</h></coordinates><panel_attributes>Commands::Attack
--
void execute()
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>4050</x><y>1380</y><w>50</w><h>140</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>30;30;30;120</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>4020</x><y>1380</y><w>50</w><h>200</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>30;30;30;180</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3610</x><y>1220</y><w>310</w><h>50</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>290;30;30;30</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>4120</x><y>680</y><w>530</w><h>90</h></coordinates><panel_attributes>Note..
bg=red
Decorator Pattern
 
Jobs change the curves for how players level up and overrides that
player's stats.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>3390</x><y>1380</y><w>350</w><h>140</h></coordinates><panel_attributes>engine::GameScreen
&lt;&lt;Frame, KeyListener&gt;&gt;
--
static final int FRAME_WIDTH
static final int FRAME_HEIGHT

Engine: e
ContentPanel: panel
--
void keyPressed(KeyEvent arg0)
void testClient()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>3060</x><y>780</y><w>210</w><h>130</h></coordinates><panel_attributes>Grouping::Formation
extends ArrayList&lt;Enemy&gt;
--
void add(String n)
void add(String[] n)
 
Enemy[] getAliveMembers()
int getAlive()



</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3130</x><y>690</y><w>50</w><h>110</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;30;90</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3000</x><y>400</y><w>760</w><h>530</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>750;30;30;30;30;520</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>70</x><y>1880</y><w>210</w><h>130</h></coordinates><panel_attributes>engine::Input
--
final static int KEY_A
final static int KEY_B
final static int KEY_UP
final static int KEY_DN
final static int KEY_LT
final static int KEY_RT</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2510</x><y>1130</y><w>320</w><h>170</h></coordinates><panel_attributes>scenes::Scene
extends JComponent implements Runnable
--
Engine: e
GameSystem: system
GameDisplay: display
--
void start()
void stop()
void next()
void render(Graphics2D g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1620</x><y>990</y><w>310</w><h>230</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>300;220;300;30;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1620</x><y>1180</y><w>310</w><h>240</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>300;230;300;30;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1620</x><y>1380</y><w>370</w><h>40</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>360;30;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1620</x><y>1380</y><w>310</w><h>110</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>300;30;300;100;30;100</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>3660</x><y>760</y><w>320</w><h>420</h></coordinates><panel_attributes>Note..
bg=blue
Level - the actor's level
exp - exp to next level
      (enemy = exp reward upon killing)
getExpCurve (player only) will return the 
       amount of exp necessary to level up
 
HP - hit points, when 0 the actor is dead
                     (can be retrieved using getAlive())
MP - is an array due to being styled after
          D&amp;D magic casting rules
Strength - Physical Attack power
Defense - Resistance against physical 
          attacks
Speed - Determines turn order and chance
          of landing an attack
Evasion - Chance of dodging and attack
Magic - Magical Attack power
Resistance - Magical defense power
Alive - is the actor capable of acting
Action - command to be executed on the
          actor's turn
Abilities - special commands the actor is
          capable of executing

paint(Graphics g) will draw the actor's sprite</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>3070</x><y>510</y><w>190</w><h>80</h></coordinates><panel_attributes>Note..
bg=blue
Enemies also can hold an
item which it may drop
upon being defeated</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>3710</x><y>310</y><w>290</w><h>90</h></coordinates><panel_attributes>Note..
bg=blue
All the variables about state and moving
deal specifically with the animation of
sprites.  They have no purpose logically
in combat, they are only for the GUI.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>0</x><y>1670</y><w>600</w><h>170</h></coordinates><panel_attributes>Note..
bg=orange
FF1-Battle-System
 
This program is aimed to recreate (for now) the Battle System used in the original
Final Fantasy for the Nintendo Entertainment System.  This includes graphical style
as well, so it won't look like the remastered versions.
 
Players will be able to create a party of 4 ponies, 6 ponies/jobs to chose from for
each member.  The battle system is turn-based and dependent on the user
assigning commands to the party members so they may attack the enemies.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>4120</x><y>2240</y><w>290</w><h>110</h></coordinates><panel_attributes>Note..
bg=blue
FINAL_WIDTH determines the width of the 
           game window
FINAL_HEIGHT determines the height of the
           game window
BACKGROUND color for the window's back</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>380</x><y>1380</y><w>270</w><h>240</h></coordinates><panel_attributes>Note..
bg=blue
music - The battlesystem is capable
    of playing invigorating music
    during the battle
 
allActors - a map of all the alive
   actors and their speed which
   which is used for figuring out
   turn order
 
commandIndex - only used during
the Issuing state, it's the current
index of the command that is
selected in the command choices</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>110</x><y>1420</y><w>230</w><h>140</h></coordinates><panel_attributes>Legend</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>110</x><y>1430</y><w>200</w><h>60</h></coordinates><panel_attributes>lt=&lt;&lt;-
Has A</panel_attributes><additional_attributes>30;40;190;40</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>110</x><y>1490</y><w>200</w><h>60</h></coordinates><panel_attributes>lt=&lt;&lt;&lt;-
Implements</panel_attributes><additional_attributes>30;40;190;40</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>110</x><y>1460</y><w>200</w><h>60</h></coordinates><panel_attributes>lt=&lt;.
Extends</panel_attributes><additional_attributes>30;40;190;40</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>4320</x><y>1780</y><w>280</w><h>190</h></coordinates><panel_attributes>Note..
bg=blue
Just for basic testing there will only be
the ability to choose attack, flee,
and a few level 1 spells.  Items are
not functional
 
Because spells are actually learned
through using and item to teach the
character it, in the future command may
be split even further into battle command
and menu commands</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3990</x><y>1380</y><w>50</w><h>260</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>30;30;30;240</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>2690</x><y>700</y><w>180</w><h>140</h></coordinates><panel_attributes>Note..
bg=blue
Formations can not only
generate an enemy by
passing a name,
but it can also generate
a group of enemies for
it to keep track of by
passing an array of names</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>4180</x><y>200</y><w>310</w><h>140</h></coordinates><panel_attributes>Note..
bg=blue
Equipment that can be equipped by the actor
is restricted to the job of the actor.

Skills that can be learned are also restricted
by job.

Equipment, however, has not yet been
implemented and for the sake of testing
is not yet necessary</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3930</x><y>520</y><w>340</w><h>50</h></coordinates><panel_attributes>lt=&lt;-</panel_attributes><additional_attributes>30;30;320;30</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>4050</x><y>1560</y><w>210</w><h>50</h></coordinates><panel_attributes>Commands::Flee
--
void execute()
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>4020</x><y>1620</y><w>210</w><h>130</h></coordinates><panel_attributes>Commands::Spell
--
boolean fire
boolean frez
boolean elec
boolean dark
boolean lght
--
void execute()
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3960</x><y>1380</y><w>50</w><h>420</h></coordinates><panel_attributes>lt=&lt;.
</panel_attributes><additional_attributes>30;30;30;400</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>3990</x><y>1770</y><w>280</w><h>50</h></coordinates><panel_attributes>Commands::ChooseSpellCommand
--
void execute()
</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>3920</x><y>1840</y><w>360</w><h>100</h></coordinates><panel_attributes>Note..
bg=blue
ChooseSpellCommand and ChooseItemCommand
are filler commands that do nothing but indicate
to the state that it should show the spell/item
list for you to choose from</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>290</x><y>1880</y><w>270</w><h>130</h></coordinates><panel_attributes>Note..
bg=blue
Just a little simple wrapper class
for key ids.  This is helpful in that
these can be loaded from a config
with custom keys in case the user
is not satisfied with the default
layout of keys.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2040</x><y>1160</y><w>320</w><h>130</h></coordinates><panel_attributes>&lt;&lt;Abstract&gt;&gt;
engine::GameSystem
--
protected GameState state
--
abstract public void update()
abstract public void setNextState()
public GameState getState()
public void keyPressed(KeyEvent evt)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3190</x><y>1310</y><w>460</w><h>90</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;440;30;440;70</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>3390</x><y>1600</y><w>350</w><h>170</h></coordinates><panel_attributes>engine::ContentPanel
&lt;&lt;JPanel&gt;&gt;
--
final int INTERNAL_RES_W
final int INTERNAL_RES_H
	
private Image dbImage
private Graphics dbg
private Engine engine
--
void render()
void paint()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Note</type><coordinates><x>3400</x><y>1790</y><w>350</w><h>110</h></coordinates><panel_attributes>Note..
bg=blue
Rendering is handled using a double buffer
technique.  Things are drawn to back buffer,
then that buffer is painted which puts it into
the front buffer position.  Buffers clear and
swap every frame.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3600</x><y>1490</y><w>50</w><h>130</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;110;30;30</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1980</x><y>1330</y><w>380</w><h>150</h></coordinates><panel_attributes>&lt;&lt;Abstract&gt;&gt;
engine::GameState
--
protected GameSystem parent
--
abstract public void start()
abstract public void handle()
abstract public void finish()
public void handleKeyInput(KeyEvent arg0)
public void setParent(GameSystem p)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2230</x><y>1260</y><w>50</w><h>90</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;70;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2330</x><y>1160</y><w>200</w><h>50</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;180;30</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2410</x><y>1370</y><w>320</w><h>110</h></coordinates><panel_attributes>engine::HUD
--
protected GameSystem parent;
--
public HUD()
public void setParent(GameSystem p)
public void update()
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2330</x><y>1260</y><w>240</w><h>130</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;220;110</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2600</x><y>1270</y><w>50</w><h>110</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;90;30;30</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>3110</x><y>1700</y><w>240</w><h>400</h></coordinates><panel_attributes>engine::Sprite
--
private static HashMap
      &lt;String, BufferedImage&gt;
            TEXTURECACHE
 
int width
int height
int x
int y
 
BufferedImage image
--
int getWidth()
int getHeight()
void setWidth()
void setHeight()
 
int getX()
int getY()
void setX()
void setY()
 
void slide(double x, double y)
	
void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2640</x><y>1450</y><w>580</w><h>270</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>560;250;560;190;220;190;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1080</x><y>690</y><w>800</w><h>800</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>170;790;30;790;30;30;790;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1110</x><y>720</y><w>770</w><h>660</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>140;650;30;650;30;30;760;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1140</x><y>750</y><w>740</w><h>490</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>110;480;30;480;30;30;730;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1170</x><y>780</y><w>710</w><h>210</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>80;200;30;200;30;30;700;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1980</x><y>920</y><w>50</w><h>430</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;410;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2110</x><y>920</y><w>50</w><h>260</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>30;240;30;30</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1870</x><y>1690</y><w>350</w><h>310</h></coordinates><panel_attributes>scenes.BattleScene.GUI::BattleHUD
--
PartySpriteDisplay psprited
PartyStatusDisplay pstatd
EnemySpriteDisplay esprited
EnemyListDisplay elistd
CommandDisplay cd
SpellDisplay sd
MessageDisplay md
GameOverDisplay gd
VictoryDisplay vd
	
BattleSystem parent

Font font

Sprite arrow
--
public void setBackground(Sprite s)
public void setParentScene(BattleSystem bs)
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>1550</y><w>400</w><h>90</h></coordinates><panel_attributes>scenes.BattleScene.System::GameState
Display Battle results when lost
--
void start()
void handle()
void finish()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1040</x><y>660</y><w>840</w><h>950</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>210;940;30;940;30;30;830;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1620</x><y>1450</y><w>310</w><h>160</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>300;30;300;150;30;150</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1860</x><y>920</y><w>40</w><h>780</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;30;770</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2160</x><y>1450</y><w>270</w><h>260</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>250;30;30;240</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2200</x><y>2400</y><w>320</w><h>260</h></coordinates><panel_attributes>scenes.CreationScene.System::CreationSystem
--
Engine e
	
Player activePlayer
int index
Party party

ChooseJobsState cjs
NamingState ns
--
void finish()
Actor getActivePlayer()
int getIndex()
Party getParty()
void setActivePlayer(Player)
void setNextState()
void update()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2250</x><y>1450</y><w>50</w><h>970</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;30;950</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>680</x><y>1200</y><w>320</w><h>80</h></coordinates><panel_attributes>scenes.CreationScene::BattleScene
--
void start()
void start(Formation f)
void update()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>870</x><y>310</y><w>1810</w><h>910</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>1790;820;1790;30;30;30;30;890</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>950</x><y>590</y><w>930</w><h>620</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>920;30;30;30;30;610</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>910</x><y>1250</y><w>970</w><h>490</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>960;480;30;480;30;30</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2650</x><y>2420</y><w>320</w><h>50</h></coordinates><panel_attributes>scenes.CreationScene::CreationScene
--
void start()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2490</x><y>2420</y><w>170</w><h>40</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;160;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2770</x><y>1270</y><w>50</w><h>1170</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>30;30;30;1150</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2870</x><y>1800</y><w>220</w><h>450</h></coordinates><panel_attributes>engine::Window
--
int x
int y
int height
int width
 
Color bg 
 
BufferedImage blcorner
BufferedImage bottom 
BufferedImage brcorner
BufferedImage left 
BufferedImage right
BufferedImage tlcorner
BufferedImage top
BufferedImage trcorner
--
int getWidth()
int getHeight()
void setWidth()
void setHeight()
 
int getX()
int getY()
void setX()
void setY()
	
void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2190</x><y>1730</y><w>940</w><h>50</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>920;30;30;30</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>1750</y><w>350</w><h>160</h></coordinates><panel_attributes>scenes.BattleScene.GUI::CommandDisplay
--
Window window
Sprite arrow
int index
	
BattleSystem parent
--
public void setParentScene(BattleSystem bs)
public void update(IssueState state)
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>1920</y><w>350</w><h>110</h></coordinates><panel_attributes>scenes.BattleScene.GUI::EnemyListDisplay
--
Window window
ArrayList&lt;String&gt; names
--
public void setParentScene(BattleSystem bs)
public void update(Formation f)
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>2040</y><w>350</w><h>230</h></coordinates><panel_attributes>scenes.BattleScene.GUI::EnemySpriteDisplay
--
Window window
Sprite background
	
HashMap&lt;Enemy, Sprite&gt; sprites
	
final int BKGVERTOFFSET
final int BKGHORZOFFSET
	
BattleSystem parent
--
public void setParentScene(BattleSystem bs)
public void update()
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>1750</y><w>310</w><h>40</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;300;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>1790</y><w>1320</w><h>380</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>1300;360;280;360;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2450</x><y>1690</y><w>680</w><h>480</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>660;30;30;30;30;460</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>1710</y><w>1560</w><h>400</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>1540;30;980;30;980;380;350;380;30;110</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>1940</y><w>300</w><h>230</h></coordinates><panel_attributes>lt=-</panel_attributes><additional_attributes>280;210;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>1940</y><w>360</w><h>160</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>350;150;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2060</y><w>370</w><h>130</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>350;30;30;110</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2120</y><w>290</w><h>60</h></coordinates><panel_attributes>lt=-</panel_attributes><additional_attributes>280;30;30;50</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>2280</y><w>350</w><h>80</h></coordinates><panel_attributes>scenes.BattleScene.GUI::GameOverDisplay
--
Window window
--
public void update()
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>2370</y><w>350</w><h>90</h></coordinates><panel_attributes>scenes.BattleScene.GUI::MessageDisplay
--
Window[] windows
MessageState message
--
public void update(MessageState m)
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>2470</y><w>350</w><h>160</h></coordinates><panel_attributes>scenes.BattleScene.GUI::PartySpriteDisplay
--
Window window
Sprite background
BattleSystem parent
	
final int BKGVERTOFFSET
final int BKGHORZOFFSET
--
public void setParentScene(BattleSystem bs)
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>2640</y><w>350</w><h>90</h></coordinates><panel_attributes>scenes.BattleScene.GUI::PartyStatusDisplay
--
Window[] windows
--
public void update()
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>2740</y><w>350</w><h>180</h></coordinates><panel_attributes>scenes.BattleScene.GUI::SpellDisplay
--
	Window window;
	Sprite arrow;
	int index = 0;
	int range = 0;
	
	BattleSystem parent;

--
public void update(IssueState state)
public void setParentScene(BattleSystem bs)
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2120</y><w>290</w><h>200</h></coordinates><panel_attributes>lt=-</panel_attributes><additional_attributes>280;30;30;190</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2060</y><w>370</w><h>270</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>350;30;30;250</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2120</y><w>290</w><h>300</h></coordinates><panel_attributes>lt=-</panel_attributes><additional_attributes>280;30;30;290</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2060</y><w>370</w><h>520</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>350;30;30;500</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2060</y><w>370</w><h>370</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>350;30;30;350</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2120</y><w>290</w><h>450</h></coordinates><panel_attributes>lt=-</panel_attributes><additional_attributes>280;30;30;440</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2120</y><w>290</w><h>560</h></coordinates><panel_attributes>lt=-</panel_attributes><additional_attributes>280;30;30;550</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2060</y><w>370</w><h>630</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>350;30;30;610</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2060</y><w>370</w><h>760</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>350;30;30;740</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2120</y><w>290</w><h>690</h></coordinates><panel_attributes>lt=-</panel_attributes><additional_attributes>280;30;30;680</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1250</x><y>2950</y><w>350</w><h>80</h></coordinates><panel_attributes>scenes.BattleScene.GUI::VictoryDisplay
--
Window window
--
public void update()
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2060</y><w>370</w><h>940</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>350;30;30;920</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1570</x><y>2120</y><w>290</w><h>870</h></coordinates><panel_attributes>lt=-</panel_attributes><additional_attributes>280;30;30;860</additional_attributes></element><element><type>com.umlet.element.base.Note</type><coordinates><x>2310</x><y>1610</y><w>470</w><h>90</h></coordinates><panel_attributes>Note..
bg=red
Facade Pattern

GUIs usually follow the facade pattern, dividing up groups of sprites into
their own classes, then having a group of those classes all handled and
rendered by the main display class for the scene.</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1910</x><y>2780</y><w>430</w><h>260</h></coordinates><panel_attributes>scenes.CreationScene.System::NamingState
Shows a table of letters to spell out a character name
--
String name
int x
int y
	
public static final char[][] letters
--
public char[][] getInputArray()
public String getName()
public int getX()
public int getY()
public void start()
public void handle()
public void finish()
public void handleKeyInput(KeyEvent arg0)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2190</x><y>2630</y><w>40</w><h>160</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;150;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2920</x><y>820</y><w>130</w><h>110</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>120;100;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2440</x><y>1000</y><w>550</w><h>1420</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>530;30;420;100;420;840;30;1400</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2490</x><y>700</y><w>2360</w><h>1890</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>1470;30;2340;400;2340;1870;30;1870</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>4430</x><y>450</y><w>410</w><h>660</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;400;30;400;650</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2440</x><y>1310</y><w>510</w><h>1110</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>490;30;390;30;390;940;30;1090</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2140</x><y>1450</y><w>120</w><h>1350</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>100;30;100;560;30;770;30;1330</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2260</x><y>1230</y><w>140</w><h>1190</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>100;30;120;30;120;360;30;360;30;1170</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>1910</x><y>3050</y><w>430</w><h>180</h></coordinates><panel_attributes>scenes.CreationScene.System::ChooseJobsState
Shows party and jobs, allows you to build party
--
Player p;
Job[] jobs;
Job selectedJob;
int index;
--
public void start()
public void handle()
public void finish()
public void handleKeyInput(KeyEvent arg0)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>1840</x><y>2190</y><w>340</w><h>910</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>330;30;30;450;30;900;70;900</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2650</x><y>2650</y><w>350</w><h>110</h></coordinates><panel_attributes>scenes.CreationScene.GUI::CreationHUD
--
public PartyDisplay partyd;
public NamingDisplay namingd;

private Font font;
--
public void update()
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2790</x><y>2440</y><w>40</w><h>220</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;210;30;30</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2850</x><y>2820</y><w>350</w><h>210</h></coordinates><panel_attributes>scenes.CreationScene.GUI::NamingDisplay
--
CreationSystem parent;
Window nameWindow;
Window inputWindow;
Sprite arrow;
	
char[][] grid;
String name;
int x;
int y;
--
public void update(NamingState s)
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2470</x><y>2820</y><w>350</w><h>100</h></coordinates><panel_attributes>scenes.CreationScene.GUI::PartyDisplay
--
PlayerWindow[] windows;
CreationSystem parent;	
--
public void update()
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2390</x><y>2980</y><w>350</w><h>190</h></coordinates><panel_attributes>scenes.CreationScene.GUI::PlayerWindow
--
Window w;
Player p;
--
public void update(Player p)
public void paint(Graphics g)</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2530</x><y>2890</y><w>130</w><h>110</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;90;110;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2630</x><y>2730</y><w>190</w><h>110</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;90;170;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2810</x><y>2730</y><w>210</w><h>110</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>190;90;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2740</x><y>2070</y><w>570</w><h>1060</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>550;30;550;1040;120;1040;30;850</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2710</x><y>3080</y><w>170</w><h>50</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>150;30;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3170</x><y>2940</y><w>140</w><h>50</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>120;30;30;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2930</x><y>2440</y><w>220</w><h>390</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;210;380</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2480</x><y>2440</y><w>180</w><h>390</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>170;30;30;380</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3130</x><y>2070</y><w>50</w><h>340</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>30;30;30;320</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>3170</x><y>2840</y><w>240</w><h>50</h></coordinates><panel_attributes>lt=-</panel_attributes><additional_attributes>30;30;220;30</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2710</x><y>2220</y><w>700</w><h>940</h></coordinates><panel_attributes>lt=-&gt;&gt;</panel_attributes><additional_attributes>30;920;680;920;680;650;380;30</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2360</x><y>430</y><w>210</w><h>120</h></coordinates><panel_attributes>&lt;&lt;Interface&gt;&gt;
java.util::Queue&lt;E&gt;
--
E element()
boolean offer(E o)
E peek()
E poll()
E remove()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2160</x><y>470</y><w>210</w><h>40</h></coordinates><panel_attributes>lt=&lt;&lt;-</panel_attributes><additional_attributes>200;30;30;30</additional_attributes></element><element><type>com.umlet.element.base.Class</type><coordinates><x>2700</x><y>0</y><w>370</w><h>390</h></coordinates><panel_attributes>&lt;&lt;List&gt;&gt;
java.util::ArrayList&lt;E&gt;
--
protected transient int modCount
--
boolean add(E o)
void add(int index, E element)
boolean addAll(Collection&lt;? extends E&gt; c)
boolean addAll(int index, Collection&lt;? extends E&gt; c)
void clear()
Object clone()
boolean contains(Object elem)
void ensureCapacity(int minCapacity)
E get(int index)
int indexOf(Object elem)
boolean isEmpty()
int lastIndexOf(Object elem)
E remove(int index)
boolean remove(Object o)
protected void removeRange(int fromIndex, int toIndex)
E set(int index, E element)
int size()
Object[] toArray)
&lt;T&gt; T[] toArray(T[] a)
void trimToSize()</panel_attributes><additional_attributes/></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2870</x><y>360</y><w>210</w><h>440</h></coordinates><panel_attributes>lt=&lt;.</panel_attributes><additional_attributes>30;30;190;420</additional_attributes></element><element><type>com.umlet.element.base.Relation</type><coordinates><x>2870</x><y>360</y><w>190</w><h>570</h></coordinates><panel_attributes>lt=.</panel_attributes><additional_attributes>30;30;180;560</additional_attributes></element></umlet_diagram>